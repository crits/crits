import json

try:
    from django.urls import reverse
except ImportError:
    from django.core.urlresolvers import reverse
from django.http import HttpResponse
from django.shortcuts import render

from crits.exploits.exploit import Exploit
from crits.core.class_mapper import class_from_id
from crits.core.crits_mongoengine import EmbeddedCampaign, json_handler
from crits.core.crits_mongoengine import EmbeddedSource
from crits.core.crits_mongoengine import create_embedded_source
from crits.core.handlers import build_jtable, jtable_ajax_list
from crits.core.handlers import jtable_ajax_delete
from crits.core.handlers import csv_export
from crits.core.user_tools import is_user_subscribed, user_sources
from crits.core.user_tools import is_user_favorite
from crits.notifications.handlers import remove_user_from_notification
from crits.services.handlers import run_triage, get_supported_services

from crits.vocabulary.relationships import RelationshipTypes
from crits.vocabulary.acls import ExploitACL

def generate_exploit_csv(request):
    """
    Generate a CSV file of the Exploit information

    :param request: The request for this CSV.
    :type request: :class:`django.http.HttpRequest`
    :returns: :class:`django.http.HttpResponse`
    """

    response = csv_export(request, Exploit)
    return response

def generate_exploit_jtable(request, option):
    """
    Generate the jtable data for rendering in the list template.

    :param request: The request for this jtable.
    :type request: :class:`django.http.HttpRequest`
    :param option: Action to take.
    :type option: str of either 'jtlist', 'jtdelete', or 'inline'.
    :returns: :class:`django.http.HttpResponse`
    """

    obj_type = Exploit
    type_ = "exploit"
    mapper = obj_type._meta['jtable_opts']
    if option == "jtlist":
        # Sets display url
        details_url = mapper['details_url']
        details_url_key = mapper['details_url_key']
        fields = mapper['fields']
        response = jtable_ajax_list(obj_type,
                                    details_url,
                                    details_url_key,
                                    request,
                                    includes=fields)
        return HttpResponse(json.dumps(response,
                                       default=json_handler),
                            content_type="application/json")
    if option == "jtdelete":
        response = {"Result": "ERROR"}
        if jtable_ajax_delete(obj_type, request):
            response = {"Result": "OK"}
        return HttpResponse(json.dumps(response,
                                       default=json_handler),
                            content_type="application/json")
    jtopts = {
        'title': "Exploits",
        'default_sort': mapper['default_sort'],
        'listurl': reverse('crits-%ss-views-%ss_listing' %
                           (type_, type_), args=('jtlist',)),
        'deleteurl': reverse('crits-%ss-views-%ss_listing' %
                             (type_, type_), args=('jtdelete',)),
        'searchurl': reverse(mapper['searchurl']),
        'fields': mapper['jtopts_fields'],
        'hidden_fields': mapper['hidden_fields'],
        'linked_fields': mapper['linked_fields'],
        'details_link': mapper['details_link'],
        'no_sort': mapper['no_sort']
    }
    jtable = build_jtable(jtopts, request)
    jtable['toolbar'] = [
        {
            'tooltip': "'Add Exploit'",
            'text': "'Add Exploit'",
            'click': "function () {$('#new-exploit').click()}",
        },
    ]
    if option == "inline":
        return render(request, "jtable.html",
                                  {'jtable': jtable,
                                   'jtid': '%s_listing' % type_,
                                   'button': '%ss_tab' % type_},
                                  )
    else:
        return render(request, "%s_listing.html" % type_,
                                  {'jtable': jtable,
                                   'jtid': '%s_listing' % type_},
                                  )

def get_exploit_details(id_, user):
    """
    Generate the data to render the Exploit details template.

    :param id_: The Exploit ObjectId to get details for.
    :type id_: str
    :param user: The user requesting this information.
    :type user: CRITsUser
    :returns: template (str), arguments (dict)
    """

    allowed_sources = user_sources(user)
    exploit = Exploit.objects(id=id_, source__name__in=allowed_sources).first()
    template = None
    args = {}

    if not user.check_source_tlp(exploit):
        exploit = None

    if not exploit:
        template = "error.html"
        error = ('Either no data exists for this Exploit or you do not have'
                 ' permission to view it.')
        args = {'error': error}
    else:
        exploit.sanitize("%s" % user)


        # remove pending notifications for user
        remove_user_from_notification("%s" % user, exploit.id, 'Exploit')

        # subscription
        subscription = {
            'type': 'Exploit',
            'id': exploit.id,
            'subscribed': is_user_subscribed("%s" % user,
                                             'Exploit',
                                             exploit.id),
        }

        #objects
        objects = exploit.sort_objects()

        #relationships
        relationships = exploit.sort_relationships("%s" % user, meta=True)

        # relationship
        relationship = {
            'type': 'Exploit',
            'value': exploit.id
        }

        #comments
        comments = {'comments': exploit.get_comments(),
                    'url_key': exploit.id}

        #screenshots
        screenshots = exploit.get_screenshots(user)

        # favorites
        favorite = is_user_favorite("%s" % user, 'Exploit', exploit.id)

        # services
        service_list = get_supported_services('Exploit')

        # analysis results
        service_results = exploit.get_analysis_results()

        args = {'objects': objects,
                'relationships': relationships,
                'relationship': relationship,
                'subscription': subscription,
                'favorite': favorite,
                'service_list': service_list,
                'service_results': service_results,
                'screenshots': screenshots,
                'exploit': exploit,
                'exploit_id': id_,
                'comments': comments,
                'ExploitACL': ExploitACL}
    return template, args

def add_new_exploit(name, cve=None, description=None, source=None,
                    source_method=None, source_reference=None, source_tlp=None,
                    campaign=None, confidence=None, user=None,
                    bucket_list=None, ticket=None,related_id=None,
                    related_type=None, relationship_type=None):
    """
    Add an Exploit to CRITs.

    :param name: The name of the exploit.
    :type name: str
    :param cve: CVE for the exploit.
    :type cve: str
    :param description: Description of the exploit.
    :type description: str
    :param source: Name of the source which provided this information.
    :type source: str
    :param source_method: Method of acquiring this data.
    :type source_method: str
    :param source_reference: A reference to this data.
    :type source_reference: str
    :param source_tlp: TLP value for this source
    :type source_reference: str
    :param campaign: A campaign to attribute to this exploit.
    :type campaign: str
    :param confidence: Confidence level in the campaign attribution.
    :type confidence: str ("low", "medium", "high")
    :param user: The user adding this exploit.
    :type user: str
    :param bucket_list: Buckets to assign to this exploit.
    :type bucket_list: str
    :param ticket: Ticket to assign to this exploit.
    :type ticket: str
    :param related_id: ID of object to create relationship with
    :type related_id: str
    :param related_type: Type of object to create relationship with
    :type related_type: str
    :param relationship_type: Type of relationship to create.
    :type relationship_type: str
    :returns: dict with keys:
              "success" (boolean),
              "message" (str),
              "object" (if successful) :class:`crits.exploits.exploit.Exploit`
    """

    is_item_new = False
    retVal = {}
    exploit = Exploit.objects(name=name).first()

    if not exploit:
        exploit = Exploit()
        exploit.name = name
        if description:
            exploit.description = description.strip()
        is_item_new = True

    username = user.username

    if isinstance(source, basestring):
        if user.check_source_write(source):
            source = [create_embedded_source(source,
                                             reference=source_reference,
                                             method=source_method,
                                             tlp=source_tlp,
                                             analyst=username)]
        else:
            return {"success": False,
                    "message": "User does not have permission to add object \
                                using source %s." % source}

    elif isinstance(source, EmbeddedSource):
        source = [source]

    if isinstance(campaign, basestring):
        c = EmbeddedCampaign(name=campaign, confidence=confidence, analyst=username)
        campaign = [c]

    if campaign:
        for camp in campaign:
            exploit.add_campaign(camp)

    if source:
        for s in source:
            exploit.add_source(s)
    else:
        return {"success" : False, "message" : "Missing source information."}

    exploit.cve = cve.strip()

    if bucket_list:
        exploit.add_bucket_list(bucket_list, user)

    if ticket:
        exploit.add_ticket(ticket, user)

    related_obj = None
    if related_id:
        related_obj = class_from_id(related_type, related_id)
        if not related_obj:
            retVal['success'] = False
            retVal['message'] = 'Related Object not found.'
            return retVal


    exploit.save(username=username)

    if related_obj and exploit and relationship_type:
        relationship_type=RelationshipTypes.inverse(relationship=relationship_type)
        exploit.add_relationship(related_obj,
                               relationship_type,
                               analyst=user,
                               get_rels=False)
        exploit.save(username=username)

    # run exploit triage
    if is_item_new:
        exploit.reload()
        run_triage(exploit, username)

    resp_url = reverse('crits-exploits-views-exploit_detail', args=[exploit.id])

    retVal['message'] = ('Success! Click here to view the new Exploit: '
                         '<a href="%s">%s</a>' % (resp_url, exploit.name))

    retVal['success'] = True
    retVal['object'] = exploit
    retVal['id'] = str(exploit.id)

    return retVal

def exploit_remove(id_, username):
    """
    Remove an Exploit from CRITs.

    :param id_: The ObjectId of the Exploit to remove.
    :type id_: str
    :param username: The user removing this Exploit.
    :type username: str
    :returns: dict with keys "success" (boolean) and "message" (str) if failed.
    """

    exploit = Exploit.objects(id=id_).first()
    if exploit:
        exploit.delete(username=username)
        return {'success': True}
    else:
        return {'success': False, 'message': 'Could not find Exploit.'}

def set_exploit_name(id_, name, user, **kwargs):
    """
    Set a Exploit name.

    :param id_: Exploit ObjectId.
    :type id_: str
    :param name: The new name.
    :type name: str
    :param user: The user updating the name.
    :type user: str
    :returns: dict with keys:
              "success" (boolean),
              "message" (str),
    """

    sources = user_sources(user)
    exploit = Exploit.objects(id=id_, source__name__in=sources).first()
    if not exploit:
        return {'success': False,
                'message': "Could not find exploit"}

    exploit.name = name.strip()
    exploit.save(username=user)
    return {'success': True}

def update_exploit_cve(id_, cve, user, **kwargs):
    """
    Update CVE for a Exploit.

    :param id_: The ObjectId of the Exploit to update.
    :type id_: str
    :param cve: The CVE we are setting.
    :type CVE: str
    :param user: The user updating the CVE.
    :type user: str
    :returns: dict
    """

    sources = user_sources(user)
    exploit = Exploit.objects(id=id_, source__name__in=sources).first()
    if not exploit:
        return {'success': False,
                'message': 'No exploit could be found.'}
    else:
        exploit.cve = cve
        exploit.save(username=user)
        return {'success': True}
